generator client {
	provider = "prisma-client"
	output   = "../lib/generated/prisma"
}

datasource db {
	provider = "postgresql"
}

model User {
	id            String    @id
	name          String
	email         String    @unique
	emailVerified Boolean   @default(false)
	image         String?
	createdAt     DateTime  @default(now())
	updatedAt     DateTime  @updatedAt
	encryptedKey  String?
	keyHash       String?
	salt          String?

	sessions           Session[]
	accounts           Account[]
	vault              Vault?
	apiKeys            ApiKey[]
	auditLogs          AuditLog[]
	recoveryCodes      RecoveryCode[]
	shares             Share[]
	emergencyAsGrantor EmergencyAccess[] @relation("EmergencyGrantor")
	emergencyAsGrantee EmergencyAccess[] @relation("EmergencyGrantee")
	secretEngines      SecretEngine[]
	folders            Folder[]

	@@map("user")
}

model Session {
	id        String   @id
	expiresAt DateTime
	token     String   @unique
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt
	ipAddress String?
	userAgent String?
	userId    String

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)

	@@map("session")
}

model Account {
	id                    String    @id
	accountId             String
	providerId            String
	userId                String
	accessToken           String?
	refreshToken          String?
	idToken               String?
	accessTokenExpiresAt  DateTime?
	refreshTokenExpiresAt DateTime?
	scope                 String?
	password              String?
	createdAt             DateTime  @default(now())
	updatedAt             DateTime  @updatedAt

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)

	@@map("account")
}

model Verification {
	id         String   @id
	identifier String
	value      String
	expiresAt  DateTime
	createdAt  DateTime @default(now())
	updatedAt  DateTime @updatedAt

	@@map("verification")
}

model Vault {
	id        String   @id @default(cuid())
	userId    String   @unique
	blobKey   String
	revision  Int      @default(0)
	size      Int      @default(0)
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt

	user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
	items Item[]

	@@map("vault")
}

model Item {
	id        String   @id @default(cuid())
	vaultId   String
	folderId  String?
	type      ItemType
	title     String
	data      String
	revision  Int      @default(0)
	favorite  Boolean  @default(false)
	deleted   Boolean  @default(false)
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt

	vault  Vault   @relation(fields: [vaultId], references: [id], onDelete: Cascade)
	folder Folder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
	tags   Tag[]
	shares Share[]

	@@index([vaultId])
	@@index([folderId])
	@@index([type])
	@@map("item")
}

model Tag {
	id     String @id @default(cuid())
	name   String
	itemId String

	item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

	@@unique([itemId, name])
	@@map("tag")
}

model Folder {
	id        String   @id @default(cuid())
	name      String
	parentId  String?
	userId    String
	color     String   @default("default")
	icon      String   @default("folder")
	order     Int      @default(0)
	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt

	user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
	parent   Folder?  @relation("FolderTree", fields: [parentId], references: [id], onDelete: SetNull)
	children Folder[] @relation("FolderTree")
	items    Item[]

	@@index([userId])
	@@index([parentId])
	@@index([order])
	@@map("folder")
}

model ApiKey {
	id        String    @id @default(cuid())
	userId    String
	keyHash   String    @unique
	hint      String
	webhook   String?
	expiresAt DateTime?
	createdAt DateTime  @default(now())
	lastUsed  DateTime?

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)

	@@index([userId])
	@@map("api_key")
}

model AuditLog {
	id        String   @id @default(cuid())
	userId    String
	action    String
	details   String?
	ip        String?
	userAgent String?
	createdAt DateTime @default(now())

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)

	@@index([userId])
	@@index([action])
	@@index([createdAt])
	@@map("audit_log")
}

model RecoveryCode {
	id        String    @id @default(cuid())
	userId    String
	hash      String
	used      Boolean   @default(false)
	usedAt    DateTime?
	createdAt DateTime  @default(now())

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)

	@@index([userId])
	@@index([hash])
	@@map("recovery_code")
}

model Share {
	id            String   @id @default(cuid())
	userId        String
	itemId        String
	encryptedData String   @db.Text
	publicKey     String
	expiresAt     DateTime
	maxViews      Int      @default(1)
	viewCount     Int      @default(0)
	passwordHash  String?
	revoked       Boolean  @default(false)
	createdAt     DateTime @default(now())
	updatedAt     DateTime @updatedAt

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)
	item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

	@@index([userId])
	@@index([itemId])
	@@index([expiresAt])
	@@map("share")
}

model EmergencyAccess {
	id                String                @id @default(cuid())
	grantorId         String
	granteeId         String
	granteeEmail      String?
	status            EmergencyAccessStatus @default(pending)
	waitDays          Int                   @default(7)
	requestedAt       DateTime?
	approvedAt        DateTime?
	deniedAt          DateTime?
	expiresAt         DateTime?
	grantorPublicKey  String?
	grantorPrivateKey String?               @db.Text
	encryptedVaultKey String?               @db.Text
	createdAt         DateTime              @default(now())
	updatedAt         DateTime              @updatedAt

	grantor User @relation("EmergencyGrantor", fields: [grantorId], references: [id], onDelete: Cascade)
	grantee User @relation("EmergencyGrantee", fields: [granteeId], references: [id], onDelete: Cascade)

	@@unique([grantorId, granteeId])
	@@index([grantorId])
	@@index([granteeId])
	@@index([status])
	@@map("emergency_access")
}

enum EmergencyAccessStatus {
	pending
	requested
	approved
	denied
	expired
}

enum ItemType {
	login
	note
	card
	identity
	ssh
	api
	otp
	passkey
}

enum EngineType {
	database
	aws
}

model SecretEngine {
	id        String     @id @default(cuid())
	userId    String
	type      EngineType
	name      String
	config    String     @db.Text
	createdAt DateTime   @default(now())
	updatedAt DateTime   @updatedAt

	user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)
	leases SecretLease[]

	@@index([userId])
	@@index([type])
	@@map("secret_engine")
}

model SecretLease {
	id          String   @id @default(cuid())
	engineId    String
	credentials String   @db.Text
	expiresAt   DateTime
	revoked     Boolean  @default(false)
	createdAt   DateTime @default(now())

	engine SecretEngine @relation(fields: [engineId], references: [id], onDelete: Cascade)

	@@index([engineId])
	@@index([expiresAt])
	@@map("secret_lease")
}
